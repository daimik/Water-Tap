esphome:
  name: water-tap
  friendly_name: Water Tap
  on_boot:
    # HIGHEST PRIORITY: Force relays OFF immediately using direct GPIO
    - priority: 1000
      then:
        - lambda: |-
            #include "driver/gpio.h"
            // Force both relay pins HIGH for OFF (inverted logic)
            // Do this BEFORE any ESPHome component initialization
            gpio_reset_pin(GPIO_NUM_23);
            gpio_set_direction(GPIO_NUM_23, GPIO_MODE_OUTPUT);
            gpio_set_pull_mode(GPIO_NUM_23, GPIO_PULLUP_ONLY);
            gpio_set_level(GPIO_NUM_23, 1);  // HIGH = OFF
            
            gpio_reset_pin(GPIO_NUM_16);
            gpio_set_direction(GPIO_NUM_16, GPIO_MODE_OUTPUT);
            gpio_set_pull_mode(GPIO_NUM_16, GPIO_PULLUP_ONLY);
            gpio_set_level(GPIO_NUM_16, 1);  // HIGH = OFF
            
            ESP_LOGI("relay_safety", "GPIO level set: Both relays forced OFF at early boot");

    # Enable external antenna
    - priority: 800
      then:
        - lambda: |-
            #include "driver/gpio.h"
            gpio_reset_pin(GPIO_NUM_3);
            gpio_set_direction(GPIO_NUM_3, GPIO_MODE_OUTPUT);
            gpio_set_level(GPIO_NUM_3, 0);
            vTaskDelay(pdMS_TO_TICKS(10));
            gpio_reset_pin(GPIO_NUM_14);
            gpio_set_direction(GPIO_NUM_14, GPIO_MODE_OUTPUT);
            gpio_set_level(GPIO_NUM_14, 1);
            ESP_LOGI("antenna", "External antenna enabled");

    # AFTER switch components initialize: Force them OFF again
    - priority: 600
      then:
        - lambda: |-
            // Ensure GPIO pins are still HIGH (OFF) after switch init
            #include "driver/gpio.h"
            gpio_set_level(GPIO_NUM_23, 1);  // HIGH = OFF
            gpio_set_level(GPIO_NUM_16, 1);  // HIGH = OFF
            ESP_LOGI("relay_safety", "GPIO reinforced after component init");

    # Explicitly turn off switches after they're fully initialized
    - priority: 200
      then:
        - switch.turn_off: relay_open_switch
        - switch.turn_off: relay_close_switch
        - delay: 50ms
        - lambda: |-
            ESP_LOGI("relay_safety", "Switches explicitly turned OFF");

    # Restore LED states ONLY - NO relay interaction
    - priority: -100
      then:
        - lambda: |-
            // Restore LEDs based on water_state WITHOUT touching relays
            if (id(water_state)) {
              id(green_led_output).turn_on();
              id(red_led_output).turn_off();
            } else {
              id(green_led_output).turn_off();
              id(red_led_output).turn_on();
            }
        - delay: 500ms
        - script.execute: sound_startup

esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  framework:
    type: esp-idf

logger:
  level: DEBUG

api:
  encryption:
    key: "change_me"

ota:
  - platform: esphome
    password: "change_me"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Water-Tap Fallback Hotspot"
    password: "password"
  on_connect:
    - output.turn_on: blue_led_output
    - script.execute: sound_wifi_connected
  on_disconnect:
    - output.turn_off: blue_led_output

captive_portal:

web_server:
  port: 80
  version: 3
  local: true

preferences:
  flash_write_interval: 5min

globals:
  - id: water_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  
  - id: last_button_press
    type: unsigned long
    restore_value: no
    initial_value: '0'
  
  - id: last_button_type
    type: int
    restore_value: no
    initial_value: '0'
  
  - id: operation_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'
  
  - id: operation_remaining_seconds
    type: int
    restore_value: no
    initial_value: '0'
  
  - id: safety_lockout_remaining
    type: int
    restore_value: no
    initial_value: '0'
  
  - id: buzzer_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'
  
  # Statistics counters
  - id: total_operations
    type: int
    restore_value: yes
    initial_value: '0'
  
  - id: total_open_count
    type: int
    restore_value: yes
    initial_value: '0'
  
  - id: total_close_count
    type: int
    restore_value: yes
    initial_value: '0'
  
  - id: total_runtime_seconds
    type: unsigned long
    restore_value: yes
    initial_value: '0'
  
  - id: last_operation_time
    type: unsigned long
    restore_value: yes
    initial_value: '0'

binary_sensor:
  # Physical buttons
  - platform: gpio
    pin:
      number: GPIO0  # D0
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Open Button"
    id: button_open
    internal: true
    filters:
      - delayed_on: 50ms
    on_press:
      - lambda: |-
          if (id(operation_in_progress)) return;
          unsigned long current_time = millis();
          unsigned long time_since_last = current_time - id(last_button_press);
          if (id(last_button_type) == 2 && time_since_last < 30000) return;
          id(last_button_press) = current_time;
          id(last_button_type) = 1;
          id(open_water_tap).execute();

  - platform: gpio
    pin:
      number: GPIO1  # D1
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Close Button"
    id: button_close
    internal: true
    filters:
      - delayed_on: 50ms
    on_press:
      - lambda: |-
          if (id(operation_in_progress)) return;
          unsigned long current_time = millis();
          unsigned long time_since_last = current_time - id(last_button_press);
          if (id(last_button_type) == 1 && time_since_last < 30000) return;
          id(last_button_press) = current_time;
          id(last_button_type) = 2;
          id(close_water_tap).execute();

  # Physical reboot button - D8 (GPIO19)
  - platform: gpio
    pin:
      number: GPIO19  # D8
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Physical Reboot Button"
    id: physical_reboot_button
    internal: true
    filters:
      - delayed_on: 50ms
    on_press:
      - switch.turn_on: restart_switch

  # Device status
  - platform: status
    name: "Device Online"
    id: device_status
    device_class: connectivity
    entity_category: diagnostic

  # WiFi connection status (internal, used by text sensor)
  - platform: status
    name: "WiFi Connected"
    id: wifi_connected
    internal: true

output:
  - platform: gpio
    pin: GPIO2  # D2 - Green LED
    id: green_led_output

  - platform: gpio
    pin: GPIO21  # D3 - Red LED
    id: red_led_output
  
  - platform: gpio
    pin: GPIO22  # D4 - Blue LED (WiFi status)
    id: blue_led_output

  # Passive buzzer on D9 (GPIO20) with PWM
  - platform: ledc
    pin: GPIO20  # D9
    id: buzzer_output
    frequency: 2000Hz

# Update countdown timers every second
interval:
  - interval: 1s
    then:
      # Update WiFi LED
      - if:
          condition:
            wifi.connected:
          then:
            - output.turn_on: blue_led_output
          else:
            - output.turn_off: blue_led_output
      
      # Update operation countdown
      - lambda: |-
          if (id(operation_remaining_seconds) > 0) {
            id(operation_remaining_seconds) -= 1;
          }
      
      # Update safety lockout countdown
      - lambda: |-
          if (id(safety_lockout_remaining) > 0) {
            id(safety_lockout_remaining) -= 1;
          } else if (!id(operation_in_progress)) {
            // Calculate remaining lockout time
            unsigned long current_time = millis();
            unsigned long time_since_last = current_time - id(last_button_press);
            if (time_since_last < 30000) {
              id(safety_lockout_remaining) = (30000 - time_since_last) / 1000;
            } else {
              id(safety_lockout_remaining) = 0;
            }
          }
      
      # SAFETY: Monitor relay states and force both OFF if conflict detected
      - lambda: |-
          if (id(relay_open_switch).state && id(relay_close_switch).state) {
            ESP_LOGE("relay_safety", "CRITICAL: Both relays active! Emergency shutdown!");
            id(relay_open_switch).turn_off();
            id(relay_close_switch).turn_off();
            id(operation_in_progress) = false;
            id(sound_error).execute();
          }

# ========== SOUND EFFECTS ==========
script:
  # Water opening sound - Ascending bubbles
  - id: sound_water_open
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(buzzer_enabled);'
          then:
            # Rising water sound effect
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 400Hz
            - output.set_level:
                id: buzzer_output
                level: 40%
            - delay: 80ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 600Hz
            - delay: 80ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 800Hz
            - delay: 100ms
            - output.turn_off: buzzer_output

  # Water closing sound - Descending flow stop
  - id: sound_water_close
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(buzzer_enabled);'
          then:
            # Descending water stop sound
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 800Hz
            - output.set_level:
                id: buzzer_output
                level: 40%
            - delay: 80ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 600Hz
            - delay: 80ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 400Hz
            - delay: 100ms
            - output.turn_off: buzzer_output

  # Operation complete - Success jingle
  - id: sound_operation_complete
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(buzzer_enabled);'
          then:
            # Happy success tone (C-E-G chord arpeggio)
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 523Hz  # C
            - output.set_level:
                id: buzzer_output
                level: 35%
            - delay: 100ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 659Hz  # E
            - delay: 100ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 784Hz  # G
            - delay: 200ms
            - output.turn_off: buzzer_output

  # Error/Warning sound - Alert pattern
  - id: sound_error
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(buzzer_enabled);'
          then:
            # Urgent warning sound
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 1000Hz
            - output.set_level:
                id: buzzer_output
                level: 50%
            - delay: 100ms
            - output.turn_off: buzzer_output
            - delay: 100ms
            - output.set_level:
                id: buzzer_output
                level: 50%
            - delay: 100ms
            - output.turn_off: buzzer_output
            - delay: 100ms
            - output.set_level:
                id: buzzer_output
                level: 50%
            - delay: 100ms
            - output.turn_off: buzzer_output

  # Startup sound - Power on chime
  - id: sound_startup
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(buzzer_enabled);'
          then:
            # Power-on ascending chime
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 523Hz  # C
            - output.set_level:
                id: buzzer_output
                level: 30%
            - delay: 150ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 659Hz  # E
            - delay: 150ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 784Hz  # G
            - delay: 150ms
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 1047Hz  # C high
            - delay: 300ms
            - output.turn_off: buzzer_output

  # WiFi connected - Quick beep
  - id: sound_wifi_connected
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(buzzer_enabled);'
          then:
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 1000Hz
            - output.set_level:
                id: buzzer_output
                level: 30%
            - delay: 100ms
            - output.turn_off: buzzer_output

  # Safety lockout warning - Low beep
  - id: sound_lockout
    mode: single
    then:
      - if:
          condition:
            lambda: 'return id(buzzer_enabled);'
          then:
            - output.ledc.set_frequency:
                id: buzzer_output
                frequency: 300Hz
            - output.set_level:
                id: buzzer_output
                level: 40%
            - delay: 200ms
            - output.turn_off: buzzer_output

  # Main water tap operations - RELAYS ONLY ON DURING 25s OPERATION
  - id: open_water_tap
    mode: single
    then:
      - lambda: |-
          if (id(operation_in_progress)) return;
          id(operation_in_progress) = true;
          id(operation_remaining_seconds) = 25;
      - script.execute: sound_water_open
      - output.turn_off: red_led_output
      - switch.turn_off: relay_close_switch
      - delay: 100ms
      - switch.turn_on: relay_open_switch
      # Pulse green LED during 25s operation
      - repeat:
          count: 25
          then:
            - output.turn_on: green_led_output
            - delay: 500ms
            - output.turn_off: green_led_output
            - delay: 500ms
      - switch.turn_off: relay_open_switch
      - lambda: |-
          id(total_operations) += 1;
          id(total_open_count) += 1;
          id(total_runtime_seconds) += 25;
          id(last_operation_time) = millis() / 1000;
          id(operation_remaining_seconds) = 0;
          id(safety_lockout_remaining) = 30;
      - globals.set:
          id: water_state
          value: 'true'
      # Solid green LED when complete
      - output.turn_on: green_led_output
      - output.turn_off: red_led_output
      - script.execute: sound_operation_complete
      - globals.set:
          id: operation_in_progress
          value: 'false'

  - id: close_water_tap
    mode: single
    then:
      - lambda: |-
          if (id(operation_in_progress)) return;
          id(operation_in_progress) = true;
          id(operation_remaining_seconds) = 25;
      - script.execute: sound_water_close
      - output.turn_off: green_led_output
      - switch.turn_off: relay_open_switch
      - delay: 100ms
      - switch.turn_on: relay_close_switch
      # Pulse red LED during 25s operation
      - repeat:
          count: 25
          then:
            - output.turn_on: red_led_output
            - delay: 500ms
            - output.turn_off: red_led_output
            - delay: 500ms
      - switch.turn_off: relay_close_switch
      - lambda: |-
          id(total_operations) += 1;
          id(total_close_count) += 1;
          id(total_runtime_seconds) += 25;
          id(last_operation_time) = millis() / 1000;
          id(operation_remaining_seconds) = 0;
          id(safety_lockout_remaining) = 30;
      - globals.set:
          id: water_state
          value: 'false'
      # Solid red LED when complete
      - output.turn_off: green_led_output
      - output.turn_on: red_led_output
      - script.execute: sound_operation_complete
      - globals.set:
          id: operation_in_progress
          value: 'false'

switch:
  # RELAY SWITCHES - Using template switches for better boot control
  # The underlying GPIO is controlled manually to ensure safe boot behavior
  - platform: template
    id: relay_open_switch
    name: "Open Relay"
    internal: true
    optimistic: true
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - if:
          condition:
            switch.is_on: relay_close_switch
          then:
            - logger.log: "Cannot turn on Open relay - Close relay is active"
          else:
            - lambda: |-
                #include "driver/gpio.h"
                gpio_set_level(GPIO_NUM_23, 0);  // LOW = ON (inverted)
                ESP_LOGI("relay", "Open relay ON");
    turn_off_action:
      - lambda: |-
          #include "driver/gpio.h"
          gpio_set_level(GPIO_NUM_23, 1);  // HIGH = OFF (inverted)
          ESP_LOGI("relay", "Open relay OFF");

  - platform: template
    id: relay_close_switch
    name: "Close Relay"
    internal: true
    optimistic: true
    restore_mode: ALWAYS_OFF
    turn_on_action:
      - if:
          condition:
            switch.is_on: relay_open_switch
          then:
            - logger.log: "Cannot turn on Close relay - Open relay is active"
          else:
            - lambda: |-
                #include "driver/gpio.h"
                gpio_set_level(GPIO_NUM_16, 0);  // LOW = ON (inverted)
                ESP_LOGI("relay", "Close relay ON");
    turn_off_action:
      - lambda: |-
          #include "driver/gpio.h"
          gpio_set_level(GPIO_NUM_16, 1);  // HIGH = OFF (inverted)
          ESP_LOGI("relay", "Close relay OFF");

  # System control
  - platform: restart
    name: "Restart Device"
    id: restart_switch
    icon: "mdi:restart"
    entity_category: config

  # Buzzer enable/disable
  - platform: template
    name: "Buzzer Enabled"
    id: buzzer_switch
    icon: "mdi:volume-high"
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    on_turn_on:
      - globals.set:
          id: buzzer_enabled
          value: 'true'
      - script.execute: sound_wifi_connected
    on_turn_off:
      - globals.set:
          id: buzzer_enabled
          value: 'false'

# ========== CONTROL BUTTONS ==========
button:
  - platform: template
    name: "Open Water"
    id: virtual_open
    icon: "mdi:valve-open"
    on_press:
      - lambda: |-
          if (id(operation_in_progress)) {
            return;
          }
          unsigned long current_time = millis();
          unsigned long time_since_last = current_time - id(last_button_press);
          if (id(last_button_type) == 2 && time_since_last < 30000) {
            id(sound_lockout).execute();
            return;
          }
          id(last_button_press) = current_time;
          id(last_button_type) = 1;
          id(open_water_tap).execute();

  - platform: template
    name: "Close Water"
    id: virtual_close
    icon: "mdi:valve-closed"
    on_press:
      - lambda: |-
          if (id(operation_in_progress)) {
            return;
          }
          unsigned long current_time = millis();
          unsigned long time_since_last = current_time - id(last_button_press);
          if (id(last_button_type) == 1 && time_since_last < 30000) {
            id(sound_lockout).execute();
            return;
          }
          id(last_button_press) = current_time;
          id(last_button_type) = 2;
          id(close_water_tap).execute();
  
  - platform: template
    name: "Reset Statistics"
    icon: "mdi:restore"
    entity_category: config
    on_press:
      - lambda: |-
          id(total_operations) = 0;
          id(total_open_count) = 0;
          id(total_close_count) = 0;
          id(total_runtime_seconds) = 0;
          id(last_operation_time) = 0;
      - script.execute: sound_operation_complete

  # Test sounds button
  - platform: template
    name: "Test Buzzer Sounds"
    icon: "mdi:music-note"
    entity_category: config
    on_press:
      - script.execute: sound_water_open
      - delay: 500ms
      - script.execute: sound_water_close
      - delay: 500ms
      - script.execute: sound_operation_complete

# ========== STATUS INFORMATION ==========
text_sensor:
  - platform: template
    name: "Water Status"
    id: water_status_display
    icon: "mdi:water-pump"
    lambda: |-
      if (id(operation_in_progress)) {
        return {"Operating"};
      } else if (id(water_state)) {
        return {"Open"};
      } else {
        return {"Closed"};
      }
    update_interval: 1s

  - platform: template
    name: "Operation Blocked"
    icon: "mdi:lock"
    lambda: |-
      if (id(operation_in_progress)) {
        return {"YES - Operation in Progress"};
      } else {
        unsigned long current_time = millis();
        unsigned long time_since_last = current_time - id(last_button_press);
        if (time_since_last < 30000) {
          return {"YES - Safety Lockout Active"};
        } else {
          return {"NO - Ready"};
        }
      }
    update_interval: 1s

  - platform: template
    name: "Relay Interlock Status"
    icon: "mdi:shield-lock"
    lambda: |-
      if (id(relay_open_switch).state && id(relay_close_switch).state) {
        ESP_LOGE("relay_safety", "BOTH RELAYS ACTIVE - EMERGENCY!");
        id(relay_open_switch).turn_off();
        id(relay_close_switch).turn_off();
        return {"ðŸ”´ EMERGENCY - Both Active! (Auto-disabled)"};
      } else if (id(relay_open_switch).state) {
        return {"âš¡ Open Relay Active"};
      } else if (id(relay_close_switch).state) {
        return {"âš¡ Close Relay Active"};
      } else {
        return {"âœ… Both Relays OFF (Idle)"};
      }
    update_interval: 250ms

  - platform: template
    name: "Last Operation Time"
    icon: "mdi:clock-outline"
    entity_category: diagnostic
    lambda: |-
      if (id(last_operation_time) == 0) {
        return {"Never"};
      }
      unsigned long seconds_ago = (millis() / 1000) - id(last_operation_time);
      unsigned long minutes_ago = seconds_ago / 60;
      unsigned long hours_ago = minutes_ago / 60;
      unsigned long days_ago = hours_ago / 24;
      
      std::string result;
      if (days_ago > 0) {
        result = std::to_string(days_ago) + " days ago";
      } else if (hours_ago > 0) {
        result = std::to_string(hours_ago) + " hours ago";
      } else if (minutes_ago > 0) {
        result = std::to_string(minutes_ago) + " minutes ago";
      } else {
        result = std::to_string(seconds_ago) + " seconds ago";
      }
      return {result};
    update_interval: 30s

  - platform: wifi_info
    ip_address:
      name: "IP Address"
      icon: "mdi:ip-network"
      entity_category: diagnostic

# ========== COUNTDOWN TIMERS ==========
sensor:
  - platform: template
    name: "Operation Countdown"
    icon: "mdi:timer-sand"
    lambda: 'return id(operation_remaining_seconds);'
    update_interval: 1s
    unit_of_measurement: "sec"
    accuracy_decimals: 0
    device_class: duration

  - platform: template
    name: "Safety Lockout Countdown"
    icon: "mdi:timer-lock"
    lambda: 'return id(safety_lockout_remaining);'
    update_interval: 1s
    unit_of_measurement: "sec"
    accuracy_decimals: 0
    device_class: duration

# ========== USAGE STATISTICS ==========
  - platform: template
    name: "Total Operations"
    lambda: 'return id(total_operations);'
    update_interval: 10s
    unit_of_measurement: "ops"
    icon: "mdi:counter"
    accuracy_decimals: 0
    state_class: total_increasing
    device_class: water
  
  - platform: template
    name: "Total Opens"
    lambda: 'return id(total_open_count);'
    update_interval: 10s
    unit_of_measurement: "ops"
    icon: "mdi:valve-open"
    accuracy_decimals: 0
    state_class: total_increasing
    device_class: water
  
  - platform: template
    name: "Total Closes"
    lambda: 'return id(total_close_count);'
    update_interval: 10s
    unit_of_measurement: "ops"
    icon: "mdi:valve-closed"
    accuracy_decimals: 0
    state_class: total_increasing
    device_class: water

  - platform: template
    name: "Total Runtime"
    lambda: |-
      unsigned long total_hours = id(total_runtime_seconds) / 3600;
      unsigned long remaining_minutes = (id(total_runtime_seconds) % 3600) / 60;
      float hours_decimal = total_hours + (remaining_minutes / 60.0);
      return hours_decimal;
    update_interval: 60s
    unit_of_measurement: "h"
    icon: "mdi:timer-sand"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: duration

# ========== DIAGNOSTICS ==========
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    icon: "mdi:wifi-strength-2"
    update_interval: 60s
    entity_category: diagnostic
    device_class: signal_strength

  - platform: uptime
    name: "Device Uptime"
    icon: "mdi:clock-check-outline"
    update_interval: 60s
    entity_category: diagnostic
    device_class: duration
